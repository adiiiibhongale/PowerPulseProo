const express = require('express');
const { body, validationResult } = require('express-validator');
const { authenticate, authorizeAdmin, authorizePermission } = require('../middleware/auth');
const MeterReading = require('../models/MeterReading');
const Consumer = require('../models/Consumer');
const Event = require('../models/Event');

// Threshold constants & debounce window
const EVENT_THRESHOLDS = {
  voltageLow: 180,
  voltageHigh: 250, // assumed over-voltage threshold (adjust via env later if needed)
  pfWarn: 0.85,
  pfCrit: 0.80,
  debounceMinutes: 5
};

async function createEventIfRecentDuplicateNotExists({ consumerId, source, type, severity, detail, raw, tag }){
  const since = new Date(Date.now() - EVENT_THRESHOLDS.debounceMinutes * 60 * 1000);
  const existing = await Event.findOne({ consumerId, source, type, detail, occurredAt: { $gte: since } });
  if(existing) return existing;
  return Event.create({ consumerId, source, type, severity, detail, raw, tags: tag?[tag]:[], autoGenerated:true });
}

const router = express.Router();

// Submit new meter reading
router.post('/reading', authenticate, authorizeAdmin, authorizePermission('write-meters'), [
  body('consumerId').isMongoId().withMessage('Valid consumer ID is required'),
  body('meterId').notEmpty().withMessage('Meter ID is required'),
  body('reading.currentReading').isNumeric().withMessage('Current reading must be a number'),
  body('reading.previousReading').isNumeric().withMessage('Previous reading must be a number')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        status: 'error',
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const readingData = {
      ...req.body,
      readBy: req.user._id,
      timestamp: new Date()
    };

    const reading = new MeterReading(readingData);
    await reading.save();

    // Auto-generate events from reading
    const { tamperDetection = {}, powerQuality = {} } = reading;
    const source = reading.meterId;
    const consumerId = reading.consumerId;

    // Tamper events
    if(tamperDetection.detected && Array.isArray(tamperDetection.type)){
      for(const t of tamperDetection.type){
        let detail;
        switch(t){
          case 'cover-open': detail = 'Cover opened detection triggered.'; break;
          case 'magnetic-tamper': detail = 'Magnetic field proximity detected.'; break;
          case 'current-bypass': detail = 'Current bypass tamper suspected.'; break;
          case 'voltage-tamper': detail = 'Voltage tamper condition detected.'; break;
          case 'meter-tilt': detail = 'Meter tilt / orientation anomaly.'; break;
          default: detail = `Tamper event: ${t}`; break;
        }
        await createEventIfRecentDuplicateNotExists({
          consumerId,
            source,
            type:'Tamper',
            severity:'Critical',
            detail,
            raw:{ tamperTypes: tamperDetection.type, severity: tamperDetection.severity },
            tag:t
        });
      }
    }

    // Voltage low
    if(typeof powerQuality.voltage === 'number' && powerQuality.voltage < EVENT_THRESHOLDS.voltageLow){
      await createEventIfRecentDuplicateNotExists({
        consumerId,
        source,
        type:'Threshold',
        severity:'Warning',
        detail:`Voltage under limit (UV): ${powerQuality.voltage}V (< ${EVENT_THRESHOLDS.voltageLow}V).`,
        raw:{ voltage: powerQuality.voltage, threshold: EVENT_THRESHOLDS.voltageLow },
        tag:'voltage-low'
      });
    }

    // Voltage high (over-voltage)
    if(typeof powerQuality.voltage === 'number' && powerQuality.voltage > EVENT_THRESHOLDS.voltageHigh){
      await createEventIfRecentDuplicateNotExists({
        consumerId,
        source,
        type:'Threshold',
        severity:'Warning', // per requirement: over voltage => Warning
        detail:`Voltage over limit (OV): ${powerQuality.voltage}V (> ${EVENT_THRESHOLDS.voltageHigh}V).`,
        raw:{ voltage: powerQuality.voltage, threshold: EVENT_THRESHOLDS.voltageHigh },
        tag:'voltage-high'
      });
    }

    // Power Factor low
    if(typeof powerQuality.powerFactor === 'number' && powerQuality.powerFactor < EVENT_THRESHOLDS.pfWarn){
      const sev = powerQuality.powerFactor < EVENT_THRESHOLDS.pfCrit ? 'Critical' : 'Warning';
      await createEventIfRecentDuplicateNotExists({
        consumerId,
        source,
        type:'Threshold',
        severity: sev,
        detail:`Power Factor low: ${powerQuality.powerFactor.toFixed(2)} (lagging).`,
        raw:{ pf: powerQuality.powerFactor, warn: EVENT_THRESHOLDS.pfWarn, crit: EVENT_THRESHOLDS.pfCrit },
        tag:'pf-low'
      });
    }

    res.status(201).json({
      status: 'success',
      message: 'Meter reading submitted successfully',
      data: { reading }
    });

  } catch (error) {
    console.error('Submit meter reading error:', error);
    res.status(500).json({
      status: 'error',
      message: 'Internal server error'
    });
  }
});

// Get meter readings with filters
router.get('/readings', authenticate, authorizeAdmin, authorizePermission('read-meters'), async (req, res) => {
  try {
    const { page = 1, limit = 10, consumerId, meterId, startDate, endDate, tamperOnly } = req.query;
    const skip = (page - 1) * limit;

    let query = {};
    
    if (consumerId) query.consumerId = consumerId;
    if (meterId) query.meterId = meterId;
    if (tamperOnly === 'true') query['tamperDetection.detected'] = true;
    
    if (startDate || endDate) {
      query.timestamp = {};
      if (startDate) query.timestamp.$gte = new Date(startDate);
      if (endDate) query.timestamp.$lte = new Date(endDate);
    }

    const readings = await MeterReading.find(query)
      .populate('consumerId', 'name consumerNumber email')
      .populate('readBy', 'name adminId')
      .sort({ timestamp: -1 })
      .skip(skip)
      .limit(parseInt(limit));

    const totalReadings = await MeterReading.countDocuments(query);

    res.status(200).json({
      status: 'success',
      data: {
        readings,
        pagination: {
          currentPage: parseInt(page),
          totalPages: Math.ceil(totalReadings / limit),
          totalReadings,
          hasNext: page * limit < totalReadings,
          hasPrev: page > 1
        }
      }
    });

  } catch (error) {
    console.error('Get meter readings error:', error);
    res.status(500).json({
      status: 'error',
      message: 'Internal server error'
    });
  }
});

module.exports = router;